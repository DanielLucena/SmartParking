Model SysADLModel;

package SysADL.types {
    value type Int { }
    value type Boolean { }
    value type String { }
    value type Void { }
    value type Real { }
enum ParkingBarrierCommandEnum { Open , Close } enum ParkingBarrierStatusEnum { Opening , Closing , Open , Closed , Blocked , Error } enum PrintButtonCommandEnum { Print } enum PaymentTypeEnum { Debit , Credit , Pix } datatype PaymentInfo { attributes : paymentType : PaymentTypeEnum ; real : Int ; cents : Int ; qrcode : Matrix ; } enum TransactionStatusEnum { Success , Failure } enum DirectionEnum { Up , Down , Left , Right } datatype VacancyDirection { attributes : direction : DirectionEnum ; quantity : Int ; } datatype Vacancy { attributes : vacancyDirection1 : VacancyDirection ; vacancyDirection2 : VacancyDirection ; }  value type Matrix { }   datatype VehiclePresenceStatus { attributes :  isPresent : Boolean ; }     datatype SectionVacancy { attributes : section : String ; quantity : Int ; } datatype CardData { attributes : entryTimestamp : Int ; paymentTimestamp : Int ; licensePlate : String ; } enum LogParkingBarrierEnum { entry , exit } enum UpdateAuthorizedEnum { add , remove , update } datatype UpdateAuthorized { attributes : command : UpdateAuthorizedEnum ; licensePlate : String ; periodAllowed : String ; } datatype VehicleCount { attributes : quantity : Int ; } datatype VehicleCountLog { attributes : quantity : Int ; } datatype LogParkingBarrier { attributes : ^type : LogParkingBarrierEnum ; timestamp : String ; licensePlate : String ; } datatype LicensePlateRead { attributes : licensePlate : String ; } datatype NFData { attributes : ^value : Decimal ; cpfOrCnpj : String ; timestamp : Int ; } value type Decimal { } enum CardHandlerCommandEnum { Collect , Eject } }

Requirement ControleDeEstacionamentoFR (0) {
    text = "Sistema Completo"

    Requirement GerenciarAcessoVeicularFR (1) {
        text = "Permite o controle de entrada de veículos no estacionamento. Abrange abertura e fechamento de cancelas e a emissão de tickets para acesso." derive AbrirCancelaFR , FecharCancelaFR , EmitirCardFR ;

        Requirement GerenciarAcessoComPlanoFR (6) {text = "Controla a entrada de veículos vinculados a planos mensais ou recorrentes, permitindo acesso sem a necessidade de ticket." }
        
        Requirement GerenciarAcessoPessoasAutorizadasFR (7) { text="Gerencia a entrada de veículos cadastrados previamente como autorizados, garantindo acesso automatizado e seguro."  }
        
        Requirement GerenciarAcessoComCardFR (8) { text= "Permite a entrada de veículos com base na emissão e posterior leitura do card, integrando com o processo de saída." derive LerCardFR ; }
    }

    Requirement GerenciarPagamentoFR (2) {
        text = "Responsável pelo processamento dos pagamentos referentes ao uso do estacionamento. Permite diferentes formas de pagamento, como crédito, débito e Pix, a partir da leitura do ticket."
        
  Requirement PagarComDebitoFR ( 11 ) { text="Permite que o usuário realize o pagamento do estacionamento utilizando cartão de débito." satisfied by SmartParkingComponents.PaymentMachineCP ; } Requirement PagarComPixFR ( 12 ) { text="Permite que o usuário realize o pagamento do estacionamento por meio de Pix." satisfied by SmartParkingComponents.PaymentMachineCP ; } Requirement PagarComCreditoFR ( 10 ) { text="Permite que o usuário realize o pagamento do estacionamento utilizando cartão de crédito." satisfied by SmartParkingComponents.PaymentMachineCP ; } }

    Requirement GerenciarVagasFR (3) { text="Monitora e controla a disponibilidade de vagas no estacionamento, atualizando em tempo real." satisfied by SmartParkingComponents.PresenceSensorControllerCP , SmartParkingComponents.DisplayPanelCP ; }

    

    Requirement LerPlacasDosVeiculosFR (5) { text="Realiza a leitura automática das placas dos veículos, na entrada e saida de veiculos." satisfied by SmartParkingComponents.LicencePlateCameraCP ; }

Requirement GerenciarSaidaVeicularFR ( 13 ) { text = "Gerencia o processo de saída dos veículos, garantindo a verificação de pagamento, leitura de ticket quando aplicável, e acionamento das cancelas." derive AbrirCancelaFR , FecharCancelaFR ; } } 
Requirement EmitirCardFR ( 16 ) { text="Emite card no momento da entrada de veículos, contendo informações necessárias para o cálculo posterior de tarifas e validação de saída." satisfied by SmartParkingComponents.CardEmitterCP , SmartParkingComponents.EntryButtonCP ; } 
Requirement LerCardFR ( 9 ) { text="Faz a leitura dos cards apresentados pelos motoristas para fins de cálculo do pagamento e validação da saída do veículo." satisfied by SmartParkingComponents.CardReaderCP ; } 
Requirement AbrirCancelaFR ( 14 ) { text="Aciona a abertura da cancela do estacionamento para permitir a entrada ou saída de veículos."} 
Requirement FecharCancelaFR ( 15 ) { text="Aciona o fechamento da cancela após a passagem do veículo, garantindo o controle de acesso e segurança."} 
package SmartParkingConnectors { import SmartParkingComponents ; import SmartParkingPorts ;  connector def EjectCardCN { participants : ~ target : EjectCardIPT ; ~ source : EjectCardOPT ; flows : Void from source to target } connector def VehiclePresenceStatusCN { participants : ~ target : VehiclePresenceIPT ; ~ source : VehiclePresenceOPT ; flows : VehiclePresenceStatus from source to target }  connector def VacancyCN { participants : ~ target : VacancyIPT ; ~ source : VacancyOPT ; flows : Vacancy from source to target }   connector def PaymentInfoCN { participants : ~ target : PaymentInfoIPT ; ~ source : PaymentInfoOPT ; flows : PaymentInfo from source to target } connector def ParkingBarrierCommandCN { participants : ~ target : ParkingBarrierCommandIPT ; ~ source : ParkingBarrierCommandOPT ; flows : ParkingBarrierCommandEnum from source to target } connector def ParkingBarrierStatusCN { participants : ~ target : ParkingBarrierStatusIPT ; ~ source : ParkingBarrierStatusOPT ; flows : ParkingBarrierStatusEnum from source to target connector def newElement { } } connector def TransactionCN { participants : ~ target : TransactionStatusIPT ; ~ source : TransactionStatusOPT ; flows : TransactionStatusEnum from source to target } connector def CardDataCN { participants : ~ source : CardDataIPT ; ~ target : CardDataOPT ; flows : CardData from source to target } connector def SectionVacancyCN { participants : ~ source : SectionVacancyIPT ; ~ target : SectionVacancyOPT ; flows : SectionVacancy from source to target } connector def UpdateAuthorizedCN { participants : ~ source : UpdateAuthorizedIPT ; ~ target : UpdateAuthorizedOPT ; flows : UpdateAuthorized from source to target } connector def LogParkingBarrierCN { participants : ~ source : LogParkingBarrierIPT ; ~ target : LogParkingBarrierOPT ; flows : LogParkingBarrier from source to target } connector def LicensePlateReadCN { participants : ~ source : LicensePlateReadIPT ; ~ target : LicensePlateReadOPT ; flows : LicensePlateRead from source to target } connector def NFDataCN { participants : ~ source : NFDataIPT ; ~ target : NFDataOPT ; flows : NFData from source to target } connector def VehicleCountCN { participants : ~ source : VehicleCountIPT ; ~ target : VehicleCountOPT ; flows : VehicleCount from source to target } connector def CardHandlerCommandCN { participants : ~ source : CardHandlerCommandOPT ; ~ target : CardHandlerCommandIPT ; flows : CardHandlerCommandEnum from source to target } } package SmartParkingComponents { import SmartParkingPorts ; import SysADL.types ;
	component def TotemControllerCP { ports : to4 : PaymentInfoOPT ;  to2 : TransactionStatusIPT ; to3 : TransactionStatusOPT ; to1 : CardDataIPT ; to5 : CardDataOPT ; to6 : NFDataOPT ; }
	component def PaymentMachineCP { ports : pm1 : PaymentInfoIPT ; pm2 : TransactionStatusOPT ; }
	component def ParkingBarrierCP { ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ;  } boundary
	component def EntryButtonCP { ports : tb1 : EjectCardOPT ; }
	 boundary
	component def DisplayPanelCP { ports :  dp1 : SectionVacancyIPT ; dp3 : SectionVacancyOPT ; dp2 : VehicleCountIPT ; } boundary
	component def LicencePlateCameraCP { ports :  lpc1 : LicensePlateReadOPT ; }
	component def SmartParkingSystem { configuration { components : ExitParkingBarrier : ExitParkingBarrierCP { using ports : expbProxy2 : LogParkingBarrierOPT ; expbProxy1 : UpdateAuthorizedIPT ; } EntryParkingBarrier : EntryParkingBarrierCP { using ports : epbProxy1 : UpdateAuthorizedIPT ; epbProxy2 : LogParkingBarrierOPT ; } Totem1 : TotemCP { using ports : to1Proxy : TransactionStatusOPT ; } Section1 : Section { using ports : SecProxy1 : SectionVacancyIPT ; SecProxy2 : SectionVacancyOPT ; } CentralControllerCP : CentralControllerCP { using ports : cec3 : UpdateAuthorizedOPT ; cec4 : SectionVacancyOPT ; cec1 : LogParkingBarrierIPT ; cec2 : TransactionStatusIPT ; cec5 : SectionVacancyIPT ; } Section2 : Section { using ports : SecProxy1 : SectionVacancyIPT ; SecProxy2 : SectionVacancyOPT ; } Totem2 : TotemCP { using ports : to1Proxy : TransactionStatusOPT ; } } } boundary
	component def LEDIndicatorCP { ports : led1 : VehiclePresenceIPT ; }
	component def PresenceSensorControllerCP { ports :   ps2 : VehicleCountIPT ; ps3 : VehicleCountOPT ; ps1 : VehiclePresenceIPT ; }
	component def CentralControllerCP { ports : cec3 : UpdateAuthorizedOPT [ 1 , 2 ] ; cec4 : SectionVacancyOPT [ 1 , 2 ] ; cec1 : LogParkingBarrierIPT [ 1 , 2 ] ; cec2 : TransactionStatusIPT [ 1 , 2 ] ; cec5 : SectionVacancyIPT [ 1 , 2 ] ; }
	component def EntryParkingBarrierControllerCP { ports : epb1 : UpdateAuthorizedIPT ; epb4 : LogParkingBarrierOPT ; epb2 : ParkingBarrierStatusIPT ; epb5 : ParkingBarrierCommandOPT ; epb6 : EjectCardOPT ; epb3 : LicensePlateReadIPT ; epb7 : CardDataOPT ; epb8 : VehiclePresenceIPT ; epb9 : EjectCardIPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } }
	component def ExitParkingBarrierControllerCP { ports : expb1 : UpdateAuthorizedIPT ; expb5 : LogParkingBarrierOPT ; expb6 : ParkingBarrierStatusIPT ;  expb3 : CardDataIPT ; expb4 : LicensePlateReadIPT ; expb7 : ParkingBarrierCommandOPT ; expb2 : CardHandlerCommandOPT ; expb8 : VehiclePresenceIPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } } boundary
	component def CardReaderCP { ports : cr1 : CardDataOPT ; }
	component def CardEmitterCP { ports :  ce1 : EjectCardIPT ; } boundary
	component def CardHandlerCP { ports :  ch1 : ParkingBarrierCommandIPT ; } boundary
	component def NFPrinterCP { ports : nfp1 : NFDataIPT ; component def EntryParkingBarrierControllerCP { ports : authorized : UpdateAuthorizedIPT ; vehicle : LogParkingBarrierOPT ; barrierStatus : ParkingBarrierStatusIPT ; barrierCmd : ParkingBarrierCommandOPT ; printCard : EjectCardIPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } } } boundary
	component def CardWriterCP { ports : cw1 : CardDataIPT ; } component def ExitParkingBarrierCP { ports : expbProxy2 : LogParkingBarrierOPT ; expbProxy1 : UpdateAuthorizedIPT ; configuration { components :  ParkingBarrierCPEx : ParkingBarrierCP { using ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ; } LicencePlateCameraCPEx : LicencePlateCameraCP { using ports : lpc1 : LicensePlateReadOPT ; } CardReaderEx : CardReaderCP { using ports : cr1 : CardDataOPT ; } CardCollectorEx : CardHandlerCP { using ports : cc1 : CardHandlerCommandIPT ; }  ExitParkingBarrierControllerCP : ExitParkingBarrierControllerCP { using ports : expb1 : UpdateAuthorizedIPT ; expb5 : LogParkingBarrierOPT ; expb6 : ParkingBarrierStatusIPT ; expb3 : CardDataIPT ; expb4 : LicensePlateReadIPT ; expb7 : ParkingBarrierCommandOPT ; expb2 : CardHandlerCommandOPT ; expb8 : VehiclePresenceIPT ; } BoundaryPresenceSensor : BoundaryPresenceSensor { using ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } delegations : expb1 to expbProxy1 expb5 to expbProxy2 } }
	component def EntryParkingBarrierCP { ports : epbProxy1 : UpdateAuthorizedIPT ; epbProxy2 : LogParkingBarrierOPT ; configuration { components :  LicencePlateCameraCPEn : LicencePlateCameraCP { using ports : lpc1 : LicensePlateReadOPT ; } ParkingBarrierCPEn : ParkingBarrierCP { using ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ; }  CardWriterEn : CardWriterCP { using ports : cw1 : CardDataIPT ; }  EntryButtonEn : EntryButtonCP { using ports : tb1 : EjectCardOPT ; } EntryParkingBarrierControllerCP : EntryParkingBarrierControllerCP { using ports : epb1 : UpdateAuthorizedIPT ; epb4 : LogParkingBarrierOPT ; epb2 : ParkingBarrierStatusIPT ; epb5 : ParkingBarrierCommandOPT ; epb6 : EjectCardOPT ; epb3 : LicensePlateReadIPT ; epb7 : CardDataOPT ; epb8 : VehiclePresenceIPT ; epb9 : EjectCardIPT ; } CardEmitterEn : CardEmitterCP { using ports : ce1 : EjectCardIPT ; } BoundaryPresenceSensor : BoundaryPresenceSensor { using ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } delegations : epb1 to epbProxy1 epb4 to epbProxy2 } } component def TotemCP { ports : to1Proxy : TransactionStatusOPT ; configuration { components : TotemControllerCP : TotemControllerCP { using ports : to4 : PaymentInfoOPT ; to2 : TransactionStatusIPT ; to3 : TransactionStatusOPT ; to1 : CardDataIPT ; to5 : CardDataOPT ; to6 : NFDataOPT ; } CardReaderTo : CardReaderCP { using ports : cr1 : CardDataOPT ; } CardWriterTo : CardWriterCP { using ports : cw1 : CardDataIPT ; } NFPrinterTo : NFPrinterCP { using ports : nfp1 : NFDataIPT ; } PaymentMachineCPTo : PaymentMachineCP { using ports : pm1 : PaymentInfoIPT ; pm2 : TransactionStatusOPT ; } delegations : to3 to to1Proxy } } component def Section { ports : SecProxy1 : SectionVacancyIPT ; SecProxy2 : SectionVacancyOPT ; configuration { components : DisplayPanel : DisplayPanelCP { using ports : dp1 : SectionVacancyIPT ; dp3 : SectionVacancyOPT ; dp2 : VehicleCountIPT ; }    LEDIndicatorCP1 : LEDIndicatorCP { using ports : led1 : VehiclePresenceIPT ; } LEDIndicatorCP2 : LEDIndicatorCP { using ports : led1 : VehiclePresenceIPT ; } LEDIndicatorCP3 : LEDIndicatorCP { using ports : led1 : VehiclePresenceIPT ; } BoundaryPresenceSensor1 : BoundaryPresenceSensor { using ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } BoundaryPresenceSensor1 : BoundaryPresenceSensor { using ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } BoundaryPresenceSensor1 : BoundaryPresenceSensor { using ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } PresenceSensorControllerCP : PresenceSensorControllerCP { using ports : ps2 : VehicleCountIPT ; ps3 : VehicleCountOPT ; ps1 : VehiclePresenceIPT ; } PresenceSensorControllerCP : PresenceSensorControllerCP { using ports : ps2 : VehicleCountIPT ; ps3 : VehicleCountOPT ; ps1 : VehiclePresenceIPT ; } PresenceSensorControllerCP : PresenceSensorControllerCP { using ports : ps2 : VehicleCountIPT ; ps3 : VehicleCountOPT ; ps1 : VehiclePresenceIPT ; } delegations : dp3 to SecProxy2 dp1 to SecProxy1 } } activity def PresenceSensorAC ( countIn : VehicleCount ) ( presence : VehiclePresenceStatus ) : ( countOut : VehicleCount ) { body { } } boundary
	component def BoundaryPresenceSensor { ports : ips2 : VehiclePresenceOPT ; ips1 : VehiclePresenceOPT ; } activity def FinalCountAN ( countInAN : VehicleCount ) ( presenceAN : VehiclePresenceStatus ) : ( countOutAN : VehicleCount ) { body { } } constraint newConstraint ( ) { } } package SmartParkingPorts { import SysADL.types ; port def VehiclePresenceOPT { flow out VehiclePresenceStatus }  port def VehiclePresenceIPT { flow in VehiclePresenceStatus }        port def PaymentInfoOPT { flow in PaymentInfo } port def PaymentInfoIPT { flow in PaymentInfo } port def VacancyIPT { flow in Vacancy } port def VacancyOPT { flow inout Vacancy } port def EjectCardIPT { flow in Void } port def EjectCardOPT { flow out Void } port def ParkingBarrierCommandIPT { flow in ParkingBarrierCommandEnum } port def ParkingBarrierCommandOPT { flow out ParkingBarrierCommandEnum } port def ParkingBarrierStatusIPT { flow in ParkingBarrierStatusEnum } port def ParkingBarrierStatusOPT { flow out ParkingBarrierStatusEnum } port def TransactionStatusOPT { flow out TransactionStatusEnum } port def TransactionStatusIPT { flow in TransactionStatusEnum } port def CardDataIPT { flow in CardData } port def CardDataOPT { flow out CardData } port def SectionVacancyIPT { flow in SectionVacancy } port def SectionVacancyOPT { flow out SectionVacancy } port def UpdateAuthorizedIPT { flow in UpdateAuthorized } port def UpdateAuthorizedOPT { flow out UpdateAuthorized } port def LogParkingBarrierIPT { flow in LogParkingBarrier } port def LogParkingBarrierOPT { flow out LogParkingBarrier } port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } port def LicensePlateReadOPT { flow out LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } port def CardHandlerCommandIPT { flow in CardHandlerCommandEnum } port def NFDataIPT { flow in NFData port def CardCollectionCommandIPT { flow in Void } } port def CardHandlerCommandOPT { flow out CardHandlerCommandEnum } port def NFDataOPT { flow out NFData } port def VehicleCountIPT { flow in VehicleCount } port def VehicleCountOPT { flow out VehicleCount } }Requirement QualidadeNFR ( 20 ) { text = "O sistema deve satisfazer tolerência a falhas, escalabilidade de modificabilidade" Requirement ModificabilidadeNFR ( 22 ) { text = "O Sistema deve ser facilmente modificável" derive ModificabilidadeDeSensoresNFR , ModificabilidadeDeCancelasNFR ; } Requirement EscalabilidadeNFR ( 21 ) { text = "O sistema deve ser escalável, podendo funcionar com poucas vagas e uma cancela de entrada e saída, como com milhares de vagas e dezenas de cancelas." } Requirement ToleranciaAFalhasNFR ( 23 ) { text = "O Sistema deve tolerar a falha de componentes" derive ToleranciaFalhaComponentesNaoEssenciaisNFR , ToleranciaAFalhasConectividadeNFR ; } } 
Requirement ModificabilidadeDeSensoresNFR ( 24 ) { text = "O sistema deve ser modular, permitindo a adição ou remoção de sensores de estacionamento sem necessitar adaptar o sistema." } 
Requirement ModificabilidadeDeCancelasNFR ( 25 ) { text = "O sistema deve permitir a adição e remoção de cancelas sem necessidade de modificações estruturais no software." } Requirement ToleranciaFalhaComponentesNaoEssenciaisNFR ( 26 ) { text = "Falhas em componentes não essenciais não devem comprometer a operação das cancelas." } Requirement ToleranciaAFalhasConectividadeNFR ( 27 ) { text = "O sistema deve garantir operação local das cancelas em caso de perda de comunicação com a central, liberando a saída para pagantes e pessoas autorizadas, também liberando a entrada de novos clientes ou de pessoas autorizadas." }