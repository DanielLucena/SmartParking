Model SysADLModel;

package SysADL.types {
    value type Int { }
    value type Boolean { }
    value type String { }
    value type Void { }
    value type Real { }
enum ParkingBarrierCommand { Open , Close } enum ParkingBarrierStatus { Opening , Closing , Open , Closed , Blocked , Error } enum PrintButtonCommand { Print } enum PaymentType { Debit , Credit , Pix } datatype PaymentInfo { attributes : paymentType : PaymentType ; real : Int ; cents : Int ; qrcode : Matrix ; } enum TransactionStatus { Success , Failure } enum Direction { Up , Down , Left , Right } datatype VacancyDirection { attributes : newAttribute : Direction ; quantity : Int ; } datatype Vacancy { attributes : vacancyDirection1 : VacancyDirection ; vacancyDirection2 : VacancyDirection ; } datatype TicketData { attributes : id : Int ; entryTimestamp : Int ; plate : String ; } value type Matrix { } datatype UserTouchInput { attributes : xPosition : Int ; yPosition : Int ; } datatype VideoFrame { attributes : positionX : Int ; positionY : Int ; r : Int ; g : Int ; b : Int ; } datatype ParkingSpaceStatus { attributes : parkingSpotId : Int ; occupied : Boolean ; } datatype VehicleInfo { attributes : plate : String ; authorized : Boolean ; } datatype ParkingBarrierStatus { attributes : status : ParkingBarrierStatus ; } datatype ParkingBarrierCommand { attributes : command : ParkingBarrierCommand ; } datatype TransactionStatus { attributes : transactionStatus : TransactionStatus ; } datatype SectionVacancy { attributes : section : String ; quantity : Int ; } datatype CardData { attributes : entryTimestamp : Int ; paymentTimestamp : Int ; licensePlate : String ; } enum LogParkingBarrierEnum { entry , exit } enum UpdateAuthorizedEnum { add , remove , update } datatype UpdateAuthorized { attributes : command : UpdateAuthorizedEnum ; licensePlate : String ; periodAllowed : String ; } datatype VehicleCount { attributes : quantity : Int ; } datatype VehicleCountLog { attributes : quantity : Int ; } datatype LogParkingBarrier { attributes : ^type : LogParkingBarrierEnum ; timestamp : String ; licensePlate : String ; } datatype LicensePlateRead { attributes : licensePlate : String ; } datatype NFData { attributes : ^value : Decimal ; cpfOrCnpj : String ; timestamp : Int ; } value type Decimal { } }

Requirement ControleDeEstacionamentoFR (0) {
    text = "Sistema Completo"

    Requirement GerenciarAcessoVeicularFR (1) {
        text = "Permite o controle de entrada de veículos no estacionamento. Abrange abertura e fechamento de cancelas e a emissão de tickets para acesso." derive AbrirCancelaFR , FecharCancelaFR , EmitirTicketFR ;

        Requirement GerenciarAcessoComPlanoFR (6) {text = "Controla a entrada de veículos vinculados a planos mensais ou recorrentes, permitindo acesso sem a necessidade de ticket." }
        
        Requirement GerenciarAcessoPessoasAutorizadasFR (7) { text="Gerencia a entrada de veículos cadastrados previamente como autorizados, garantindo acesso automatizado e seguro." derive FecharCancelaFR ; }
        
        Requirement GerenciarAcessoComTicketFR (8) { text= "Permite a entrada de veículos com base na emissão e posterior leitura de tickets, integrando com o processo de saída." derive GerenciarSaidaVeicularFR , LerTicketFR ; }
    }

    Requirement GerenciarPagamentoFR (2) {
        text = "Responsável pelo processamento dos pagamentos referentes ao uso do estacionamento. Permite diferentes formas de pagamento, como crédito, débito e Pix, a partir da leitura do ticket."
        
    derive LerTicketFR , PagarComCreditoFR , PagarComDebitoFR , PagarComPixFR ; }

    Requirement GerenciarVagasFR (3) { text="Monitora e controla a disponibilidade de vagas no estacionamento, atualizando em tempo real."}

    Requirement MonitorarDeslocamentoVeiculosFR (4) { text="Acompanha o deslocamento de veículos dentro do estacionamento, possibilitando maior segurança e controle operacional."}

    Requirement LerPlacasDosVeiculosFR (5) { text="Realiza a leitura automática das placas dos veículos, na entrada e saida de veiculos."}

Requirement GerenciarSaidaVeicularFR ( 13 ) { text = "Gerencia o processo de saída dos veículos, garantindo a verificação de pagamento, leitura de ticket quando aplicável, e acionamento das cancelas." derive AbrirCancelaFR , FecharCancelaFR ; } } 
Requirement EmitirTicketFR ( 16 ) { text="Emite tickets no momento da entrada de veículos, contendo informações necessárias para o cálculo posterior de tarifas e validação de saída."} 
Requirement LerTicketFR ( 9 ) { text="Faz a leitura dos tickets apresentados pelos motoristas para fins de cálculo do pagamento e validação da saída do veículo."} 
Requirement PagarComCreditoFR ( 10 ) { text="Permite que o usuário realize o pagamento do estacionamento utilizando cartão de crédito."} 
Requirement PagarComDebitoFR ( 11 ) { text="Permite que o usuário realize o pagamento do estacionamento utilizando cartão de débito."} 
Requirement PagarComPixFR ( 12 ) { text="Permite que o usuário realize o pagamento do estacionamento por meio de Pix."} 
Requirement AbrirCancelaFR ( 14 ) { text="Aciona a abertura da cancela do estacionamento para permitir a entrada ou saída de veículos."} 
Requirement FecharCancelaFR ( 15 ) { text="Aciona o fechamento da cancela após a passagem do veículo, garantindo o controle de acesso e segurança."} 
package SmartParkingConnectors { import SmartParkingComponents ; import ParkingBarrierStatus ; connector def VideoFeedCN { participants : ~ target : VideoFeedIPT ; ~ source : VideoFeedOPT ; flows : VideoFrame from source to target } connector def PrintTicketButtonCN { participants : ~ target : EjectCardIPT ; ~ source : EjectCardOPT ; flows : Void from source to target } connector def ParkingSpaceStatusCN { participants : ~ target : VehiclePresenceIPT ; ~ source : VehiclePresenceOPT ; flows : ParkingSpaceStatus from source to target } connector def TicketDataCN { participants : ~ target : TicketDataIPT ; ~ source : TicketDataOPT ; flows : TicketData from source to target } connector def VacancyCN { participants : ~ target : VacancyIPT ; ~ source : VacancyOPT ; flows : Vacancy from source to target } connector def VehicleInfoCN { participants : ~ target : VehicleInfoIPT ; ~ source : VehicleInfoOPT ; flows : VehicleInfo from source to target } connector def UserTouchInputCN { participants : ~ target : UserTouchIPT ; ~ source : UserTouchOPT ; flows : VehicleInfo from source to target } connector def PaymentInfoCN { participants : ~ target : PaymentInfoIPT ; ~ source : PaymentInfoOPT ; flows : PaymentInfo from source to target } connector def ParkingBarrierCommandCN { participants : ~ target : ParkingBarrierCommandIPT ; ~ source : ParkingBarrierCommandOPT ; flows : ParkingBarrierCommand from source to target } connector def ParkingBarrierStatusCN { participants : ~ target : ParkingBarrierStatusIPT ; ~ source : ParkingBarrierStatusOPT ; flows : ParkingBarrierStatus from source to target connector def newElement { } } connector def Transaction { participants : ~ target : TransactionStatusIPT ; ~ source : TransactionStatusOPT ; flows : TransactionStatus from source to target } connector def CardData { participants : ~ source : CardDataIPT ; ~ target : CardDataOPT ; flows : CardData from source to target } connector def SectionVacancy { participants : ~ source : SectionVacancyIPT ; ~ target : SectionVacancyOPT ; flows : SectionVacancy from source to target } connector def UpdateAuthorized { participants : ~ source : UpdateAuthorizedIPT ; ~ target : UpdateAuthorizedOPT ; flows : UpdateAuthorized from source to target } connector def LogParkingBarrier { participants : ~ source : LogParkingBarrierIPT ; ~ target : LogParkingBarrierOPT ; flows : LogParkingBarrier from source to target } connector def LicensePlateRead { participants : ~ source : LicensePlateReadIPT ; ~ target : LicensePlateReadOPT ; flows : LicensePlateRead from source to target } connector def NFData { participants : ~ source : NFDataIPT ; ~ target : NFDataOPT ; flows : NFData from source to target } } package SmartParkingComponents { import ParkingBarrierStatus ; import SysADL.types ;
	component def TotemCP { ports : to4 : PaymentInfoOPT ;  to2 : TransactionStatusIPT ; to3 : TransactionStatusOPT ; to1 : CardDataIPT ; to5 : CardDataOPT ; to6 : NFDataOPT ; }
	component def PaymentMachineCP { ports : pm1 : PaymentInfoIPT ; pm2 : TransactionStatusOPT ; }
	component def ParkingBarrierCP { ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ;  } boundary
	component def TicketButton { ports : tb1 : EjectCardOPT ; }
	 boundary
	component def DisplayPanel { ports : dp1 : VacancyIPT ; } boundary
	component def LicencePlateCameraCP { ports :  lpc1 : LicensePlateReadOPT ; }
	component def SmartParkingSystem { configuration { } } boundary
	component def LEDIndicatorCP { ports : led1 : VehiclePresenceIPT ; }  boundary
	component def PresenceSensorCP { ports : ps2 : VehiclePresenceOPT ; ps1 : VehicleInfoIPT ; }
	component def CentralControllerCP { ports : cec3 : UpdateAuthorizedOPT ; cec4 : SectionVacancyOPT ; cec1 : LogParkingBarrierIPT ; cec2 : TransactionStatusIPT ; }
	component def EntryParkingBarrierControllerCP { ports : epb1 : UpdateAuthorizedIPT ; epb4 : LogParkingBarrierOPT ; epb2 : ParkingBarrierStatusIPT ; epb5 : ParkingBarrierCommandOPT ; epb6 : EjectCardOPT ; epb3 : LicensePlateReadIPT ; epb7 : CardDataOPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } }
	component def ExitParkingBarrierControllerCP { ports : expb1 : UpdateAuthorizedIPT ; expb5 : LogParkingBarrierOPT ; expb6 : ParkingBarrierStatusIPT ; expb2 : EjectCardIPT ; expb3 : CardDataIPT ; expb4 : LicensePlateReadIPT ; expb7 : ParkingBarrierCommandOPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } } boundary
	component def CardReader { ports : cr1 : CardDataOPT ; }
	component def CardEmitter { ports : ce1 : LicensePlateReadIPT ; } boundary
	component def CardCollector { ports : cc1 : CardCollectionCommandIPT ; } boundary
	component def NFPrinter { ports : nfp1 : NFDataIPT ; component def EntryParkingBarrierControllerCP { ports : authorized : UpdateAuthorizedIPT ; vehicle : LogParkingBarrierOPT ; barrierStatus : ParkingBarrierStatusIPT ; barrierCmd : ParkingBarrierCommandOPT ; printCard : EjectCardIPT ; port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } } } boundary
	component def CardWriter { ports : cw1 : CardDataIPT ; } component def ExitParkingBarrier { ports : expbProxy2 : LogParkingBarrierOPT ; expbProxy1 : UpdateAuthorizedIPT ; configuration { components : ExitParkingBarrierControllerCP : ExitParkingBarrierControllerCP { using ports : expb1 : UpdateAuthorizedIPT ; expb5 : LogParkingBarrierOPT ; expb6i : ParkingBarrierStatusIPT ; expb2 : EjectCardIPT ; expb3 : CardDataIPT ; expb4 : LicensePlateReadIPT ; expb7 : ParkingBarrierCommandOPT ; } ParkingBarrierCP : ParkingBarrierCP { using ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ; } LicencePlateCameraCP : LicencePlateCameraCP { using ports : lpc1 : LicensePlateReadOPT ; } CardReader : CardReader { using ports : cr1 : CardDataOPT ; } CardCollector : CardCollector { using ports : cc1 : CardCollectionCommandIPT ; } delegations : expb1 to expbProxy1 expb5 to expbProxy2 } }
	component def EntryParkingBarrier { ports : epbProxy1 : UpdateAuthorizedIPT ; epbProxy2 : LogParkingBarrierOPT ; configuration { components :  LicencePlateCameraCP : LicencePlateCameraCP { using ports : lpc1 : LicensePlateReadOPT ; } ParkingBarrierCP : ParkingBarrierCP { using ports : pb2 : ParkingBarrierCommandIPT ; pb1 : ParkingBarrierStatusOPT ; } EntryParkingBarrierControllerCP : EntryParkingBarrierControllerCP { using ports : epb1 : UpdateAuthorizedIPT ; epb4 : LogParkingBarrierOPT ; epb2 : ParkingBarrierStatusIPT ; epb5 : ParkingBarrierCommandOPT ; epb6 : EjectCardOPT ; epb3 : LicensePlateReadIPT ; epb7 : CardDataOPT ; } CardWriter : CardWriter { using ports : cw1 : CardDataIPT ; } CardCollector : CardCollector { using ports : cc1 : CardCollectionCommandIPT ; } delegations : epb1 to epbProxy1 epb4 to epbProxy2 } } } package ParkingBarrierStatus { import SysADL.types ; port def VehiclePresenceOPT { flow out ParkingSpaceStatus } port def VideoFeedOPT { flow out VideoFrame } port def VehiclePresenceIPT { flow in ParkingSpaceStatus } port def VideoFeedIPT { flow in VideoFrame } port def TicketDataIPT { flow in TicketData } port def TicketDataOPT { flow out TicketData } port def VehicleInfoIPT { flow in VehicleInfo } port def VehicleInfoOPT { flow out VehicleInfo } port def UserTouchIPT { flow in UserTouchInput } port def UserTouchOPT { flow in VehicleInfo } port def PaymentInfoOPT { flow in PaymentInfo } port def PaymentInfoIPT { flow in PaymentInfo } port def VacancyIPT { flow in Vacancy } port def VacancyOPT { flow inout Vacancy } port def EjectCardIPT { flow in Void } port def EjectCardOPT { flow out Void } port def ParkingBarrierCommandIPT { flow in ParkingBarrierCommand } port def ParkingBarrierCommandOPT { flow out ParkingBarrierCommand } port def ParkingBarrierStatusIPT { flow in ParkingBarrierStatus } port def ParkingBarrierStatusOPT { flow out ParkingBarrierStatus } port def TransactionStatusOPT { flow out TransactionStatus } port def TransactionStatusIPT { flow in TransactionStatus } port def CardDataIPT { flow in CardData } port def CardDataOPT { flow out CardData } port def SectionVacancyIPT { flow in SectionVacancy } port def SectionVacancyOPT { flow out SectionVacancy } port def UpdateAuthorizedIPT { flow in UpdateAuthorized } port def UpdateAuthorizedOPT { flow out UpdateAuthorized } port def LogParkingBarrierIPT { flow in LogParkingBarrier } port def LogParkingBarrierOPT { flow out LogParkingBarrier } port def LicensePlateReadIPT { flow in LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } port def LicensePlateReadOPT { flow out LicensePlateRead port def LogParkingBarrierIPT { flow in LogParkingBarrier } } port def CardCollectionCommandIPT { flow in Void } port def NFDataIPT { flow in NFData port def CardCollectionCommandIPT { flow in Void } } port def CardCollectionCommandOPT { flow out Void } port def NFDataOPT { flow out NFData } }